% Created 2020-01-22 Wed 15:54
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Vaibhav Pujari}
\date{\today}
\title{Foundations of Haskell}
\hypersetup{
 pdfauthor={Vaibhav Pujari},
 pdftitle={Foundations of Haskell},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.3)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Lambda calculus and Category theory}
\label{sec:org3dd5759}
\begin{itemize}
\item Everything is a function
\item There is no error reporting - not that practical because there is no help from compiler
\item If we introduce error checking and types, we deviate from lambda calculus because not every expression is correct. But we also gain a lot of practical value
\item This then becomes a category - because in category composition is not arbitrary, it is constrained by morphisms
\end{itemize}
\section{The language}
\label{sec:org5892609}
\subsection{Data types}
\label{sec:org305db3e}
\begin{verbatim}
x :: Int
x = 5
\end{verbatim}
\subsection{Function types}
\label{sec:org3b97478}
Types are sets and in category of sets, a function is a member of Hom-set between two objects, so its a member of some other object in the same category (every set is an object)
\subsection{Partial functions}
\label{sec:org816f474}
\begin{itemize}
\item Recursion can create programs that never terminate
\item Well-founded recursion - compiler can prove that it terminates. But its a theoretical concept because for every algorithm that claims to find out if a recursion is well-founded or not, there always exists a particual recursion that breaks the algorithm
\item Therefore, in practice we need partial functions. A partial function gives result when it terminates, but there is no guarantee that it will terminate
\end{itemize}
\subsection{Composition}
\label{sec:org97e878e}
\begin{verbatim}
(.) :: (b->c) -> (a->b) -> a -> c
(g . f) x = g ( f x )
\end{verbatim}
Polymorphic types and higher order functions are foundational in haskell as opposed to a later added feature in most common languages
\subsection{Functors}
\label{sec:org7e9a78e}
\begin{itemize}
\item A structure-preserving mapping between two categories
\begin{itemize}
\item To preserve objects, we just need a type constructor
\end{itemize}

F: Ob(Hask) \(\to\) Ob(Hask)

\begin{itemize}
\item To preserve morphism structure, we need \texttt{fmap}. \texttt{fmap} maps morphism in first category to a morphism in second category such that it is still composable in the same way as original morphism was composable
\end{itemize}

fmap: Hom\textsubscript{Hask} \(\to\) Hom\textsubscript{Hask}

\item Shrinking the structure is a special case of preserving. When objects collapse, the morphisms must follow
\item There is a category \texttt{Cat}, in which objects are smaller categories and morphisms are functors
\end{itemize}
\end{document}
